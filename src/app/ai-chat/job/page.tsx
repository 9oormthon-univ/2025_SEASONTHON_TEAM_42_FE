'use client';

import { useEffect, useState, useCallback } from 'react';
import { useQuery } from '@tanstack/react-query';
import Image from 'next/image';
import {
  useChatHistory,
  ChatHistoryProvider,
} from '@/contexts/ChatHistoryContext';
import MessageSection from '@/components/features/chat/MessageSection';
import ChatInput from '@/components/ui/ChatInput';
import ProgressBar from '@/components/ui/ProgressBar';
import { createAiChatFlow } from '@/data/ai-chat-job-list';
import { UserResponse } from '@/types/user';
import { generateExpertType } from '@/utils/expertTypeGenerator';

interface Occupation {
  imageUrl: string;
  occupationName: string;
  description: string;
  strength: string;
  workCondition: string;
  wish: string;
  score: string;
}

interface JobRecommendations {
  first: Occupation;
  second: Occupation;
  third: Occupation;
}

interface StrengthReport {
  strength: string;
  experience: string;
  keyword: string[];
  job: string[];
}

interface ApiStrengthReport {
  strength: string;
  experience: string;
  keyword: string[];
  job: string[];
}

function AIChatJobContent() {
  // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
  const { data: userData, isLoading: userLoading } = useQuery<UserResponse>({
    queryKey: ['user', 'profile'],
    queryFn: () => fetch('/api/auth/user').then((res) => res.json()),
    retry: 1,
    staleTime: 30 * 60 * 1000, // Îç∞Ïù¥ÌÑ∞Í∞Ä 30Î∂ÑÎèôÏïà freshÏÉÅÌÉúÎ°ú Ïú†ÏßÄ
  });

  const userName = userData?.data?.name ? `${userData.data.name}Îãò` : 'Îãò';

  const aiChatFlow = createAiChatFlow(userName);

  const {
    messages,
    currentStep,
    isCompleted,
    addBotMessage,
    addUserMessage,
    addComponentMessage,
    removeMessagesByType,
    nextStep,
    completeChat,
  } = useChatHistory();

  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);
  const [textInput, setTextInput] = useState('');
  const [showCurrentQuestion, setShowCurrentQuestion] = useState(false);
  const [dynamicOptions, setDynamicOptions] = useState<string[]>([]);
  const [isLoadingOptions, setIsLoadingOptions] = useState(false);
  const [optionsFetched, setOptionsFetched] = useState<Set<number>>(new Set());
  const [jobRecommendations, setJobRecommendations] =
    useState<JobRecommendations | null>(null);
  const [isLoadingRecommendations, setIsLoadingRecommendations] =
    useState(false);
  const [, setShowJobCards] = useState(false);
  const [completionFlowStarted, setCompletionFlowStarted] = useState(false);
  const [jobMessageAdded, setJobMessageAdded] = useState(false);
  const [strengthReports, setStrengthReports] = useState<StrengthReport[]>([]);
  const [strengthReportAdded, setStrengthReportAdded] = useState(false);

  // Ï¥àÍ∏∞ intro Î©îÏãúÏßÄ
  useEffect(() => {
    if (messages.length === 0 && !userLoading && userData) {
      addBotMessage(aiChatFlow.intro.messages.join('\n'), 0);
      setShowCurrentQuestion(true);
    }
  }, [
    messages.length,
    userLoading,
    userData,
    aiChatFlow.intro.messages,
    addBotMessage,
  ]);

  // ÌòÑÏû¨ Îã®Í≥ÑÏóê Îî∞Î•∏ ÏßàÎ¨∏ ÌëúÏãú
  useEffect(() => {
    if (
      currentStep > 0 &&
      currentStep <= aiChatFlow.questions.length &&
      showCurrentQuestion
    ) {
      const currentQuestion = aiChatFlow.questions.find(
        (q) => q.step === currentStep
      );
      if (currentQuestion) {
        addBotMessage(currentQuestion.message.join('\n'), currentQuestion.id);
      }
      setShowCurrentQuestion(false);
    } else if (currentStep > aiChatFlow.questions.length && !isCompleted) {
      completeChat();
    }
  }, [
    currentStep,
    showCurrentQuestion,
    isCompleted,
    aiChatFlow,
    addBotMessage,
    completeChat,
  ]);

  // choiceÎÇò mixed ÌÉÄÏûÖ ÏßàÎ¨∏ÏóêÏÑú ÎèôÏ†Å ÏòµÏÖò Ï°∞Ìöå
  useEffect(() => {
    const currentQuestion = aiChatFlow.questions.find(
      (q) => q.step === currentStep
    );

    if (
      currentQuestion &&
      currentQuestion.step <= 7 &&
      (currentQuestion.type === 'choice' || currentQuestion.type === 'mixed') &&
      !optionsFetched.has(currentQuestion.step) &&
      !isLoadingOptions
    ) {
      const fetchOptions = async () => {
        setIsLoadingOptions(true);

        try {
          const response = await fetch(
            `/api/chat/jobs/options/${currentQuestion.step}`
          );
          const data = await response.json();

          if (data.result === 'SUCCESS' && data.data?.optionList) {
            setDynamicOptions(data.data.optionList);
          } else {
            setDynamicOptions([]);
          }
        } catch (error) {
          console.error('ÏòµÏÖò Ï°∞Ìöå Ïã§Ìå®:', error);
          setDynamicOptions([]);
        } finally {
          setIsLoadingOptions(false);
          setOptionsFetched((prev) => new Set(prev.add(currentQuestion.step)));
        }
      };

      fetchOptions();
    }
  }, [currentStep, aiChatFlow.questions, optionsFetched, isLoadingOptions]);

  // AI Ï±ÑÌåÖ ÏôÑÎ£å ÌõÑ Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
  const fetchJobRecommendations = useCallback(async () => {
    setIsLoadingRecommendations(true);

    try {
      // 1. Ï±ÑÌåÖ ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå
      await fetch('/api/chat/jobs/history/answer');

      // 2. Í∞ïÏ†ê Î¶¨Ìè¨Ìä∏ Ï°∞Ìöå
      const strengthResponse = await fetch('/api/chat/strength/result', {
        method: 'POST',
      });
      const strengthData = await strengthResponse.json();

      if (
        strengthData.result === 'SUCCESS' &&
        strengthData.data?.reportList?.length > 0
      ) {
        const reports = strengthData.data.reportList.map(
          (report: ApiStrengthReport) => ({
            strength: report.strength.replace(/ÏûÖÎãàÎã§\.$/, ''),
            experience: report.experience,
            keyword: report.keyword,
            job: report.job,
          })
        );

        setStrengthReports(reports);

        // Î°úÎî© Î©îÏãúÏßÄ Ï†úÍ±∞
        removeMessagesByType('loading');

        // Í∞ïÏ†ê Î¶¨Ìè¨Ìä∏ ÌëúÏãú
        const expertType = generateExpertType(reports[0].strength);
        addBotMessage(
          `ÏàòÍ≥† ÎßéÏúºÏÖ®Ïñ¥Ïöî ${userName}! üôè\n${userName}ÏùÄ **${expertType}**ÏûÖÎãàÎã§.`
        );
      } else {
        console.error('Í∞ïÏ†ê Î¶¨Ìè¨Ìä∏ Ï°∞Ìöå Ïã§Ìå®:', strengthData.error);
        removeMessagesByType('loading');
      }

      // 3. ÏßÅÏóÖ Ï∂îÏ≤ú Î°úÎî© Î©îÏãúÏßÄ ÌëúÏãú
      addComponentMessage('loading', {
        loadingType: 'jobRecommendation',
      });

      // Ïû†Ïãú ÎåÄÍ∏∞ ÌõÑ ÎßûÏ∂§Ìòï ÏßÅÏóÖ Ï∂îÏ≤ú Ï°∞Ìöå
      await new Promise((resolve) => setTimeout(resolve, 1000));

      const recommendResponse = await fetch(
        '/api/chat/jobs/recommend/occupation'
      );
      const recommendData = await recommendResponse.json();

      if (recommendData.result === 'SUCCESS') {
        setJobRecommendations(recommendData.data);
      } else {
        console.error('ÏßÅÏóÖ Ï∂îÏ≤ú Ïã§Ìå®:', recommendData.error);
      }
    } catch (error) {
      console.error('Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
    } finally {
      setIsLoadingRecommendations(false);
    }
  }, [userName, addBotMessage, removeMessagesByType, addComponentMessage]);

  // Ï±ÑÌåÖ ÏôÑÎ£å Ïãú Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
  useEffect(() => {
    if (isCompleted && !completionFlowStarted) {
      setCompletionFlowStarted(true);

      // 1Îã®Í≥Ñ: Í∞ïÏ†ê Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ï§ë Î°úÎî©
      setTimeout(() => {
        addComponentMessage('loading', { loadingType: 'strengthReport' });

        // 2Îã®Í≥Ñ: Í∞ïÏ†ê Î¶¨Ìè¨Ìä∏ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        setTimeout(() => {
          fetchJobRecommendations();
        }, 1000);
      }, 1000);
    }
  }, [isCompleted, completionFlowStarted]); // eslint-disable-line react-hooks/exhaustive-deps

  // ÏßÅÏóÖ Ï∂îÏ≤ú Îç∞Ïù¥ÌÑ∞Í∞Ä Î°úÎìúÎêòÎ©¥ Î©îÏãúÏßÄÏôÄ Ïπ¥Îìú ÌëúÏãú
  useEffect(() => {
    if (jobRecommendations && !jobMessageAdded) {
      setJobMessageAdded(true);

      // Î°úÎî© Î©îÏãúÏßÄ Ï†úÍ±∞
      removeMessagesByType('loading');

      setTimeout(() => {
        addBotMessage(
          'Ïù¥ Í∞ïÏ†êÏùÑ ÏÇ¥Î†§ Ï∂îÏ≤úÎìúÎ¶¨Îäî ÏßÅÏóÖ TOP 3ÏûÖÎãàÎã§.\nÎ≥Ñ ÏïÑÏù¥ÏΩòÏùÑ ÎàåÎü¨ Í¥ÄÏã¨Î™©Î°ùÏóê Ï†ÄÏû•ÌïòÏÑ∏Ïöî!'
        );

        setTimeout(() => {
          addComponentMessage('jobCards', jobRecommendations);
          setShowJobCards(true);
        }, 1500);
      }, 500);
    }
  }, [
    jobRecommendations,
    jobMessageAdded,
    removeMessagesByType,
    addBotMessage,
    addComponentMessage,
    setShowJobCards,
  ]);

  useEffect(() => {
    if (strengthReports.length > 0 && !strengthReportAdded) {
      setStrengthReportAdded(true);

      removeMessagesByType('loading');

      setTimeout(() => {
        strengthReports.forEach((report, index) => {
          setTimeout(() => {
            addComponentMessage('strengthReport', report);
          }, index);
        });
      }, 500);
    }
  }, [
    strengthReports,
    strengthReportAdded,
    jobRecommendations,
    jobMessageAdded,
    removeMessagesByType,
    addComponentMessage,
  ]);

  const getCurrentQuestion = () => {
    if (currentStep === 0) return null;
    return aiChatFlow.questions.find((q) => q.step === currentStep);
  };

  const handleOptionClick = (option: string) => {
    setSelectedOptions((prev) =>
      prev.includes(option)
        ? prev.filter((o) => o !== option)
        : [...prev, option]
    );
  };

  const handleCompleteClick = async () => {
    const currentQuestion = getCurrentQuestion();
    let userResponse = '';

    if (selectedOptions.length > 0) {
      userResponse = selectedOptions.join(', ');
    }

    if (textInput.trim()) {
      userResponse = userResponse ? `${userResponse}, ${textInput}` : textInput;
    }

    if (userResponse || selectedOptions.length > 0) {
      addUserMessage(userResponse, currentQuestion?.id, selectedOptions);

      // APIÎ°ú ÎãµÎ≥Ä Ï†ÄÏû•
      if (currentQuestion?.id) {
        try {
          await fetch('/api/chat/jobs/save/answer', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              sequence: currentQuestion.id,
              answer: userResponse,
            }),
          });
        } catch (error) {
          console.error('ÎãµÎ≥Ä Ï†ÄÏû• Ïã§Ìå®:', error);
        }
      }
    }

    // Îã§Ïùå Îã®Í≥ÑÎ°ú Ïù¥Îèô
    if (currentStep < aiChatFlow.questions.length) {
      nextStep();
      setShowCurrentQuestion(true);
    } else {
      nextStep(); // Í≤∞Í≥º ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
    }

    // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    setSelectedOptions([]);
    setTextInput('');
  };

  const handleSkipClick = async () => {
    const currentQuestion = getCurrentQuestion();
    addUserMessage('Í±¥ÎÑàÎõ∞Í∏∞', currentQuestion?.id);

    // APIÎ°ú Îπà ÎãµÎ≥Ä Ï†ÄÏû•
    if (currentQuestion?.id) {
      try {
        await fetch('/api/chat/jobs/save/answer', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            sequence: currentQuestion.id,
            answer: '',
          }),
        });
      } catch (error) {
        console.error('Í±¥ÎÑàÎõ∞Í∏∞ ÎãµÎ≥Ä Ï†ÄÏû• Ïã§Ìå®:', error);
      }
    }

    // Îã§Ïùå Îã®Í≥ÑÎ°ú Ïù¥Îèô
    if (currentStep < aiChatFlow.questions.length) {
      nextStep();
      setShowCurrentQuestion(true);
    } else {
      nextStep(); // Í≤∞Í≥º ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
    }

    // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    setSelectedOptions([]);
    setTextInput('');
  };

  const handleStartClick = () => {
    addUserMessage('ÏãúÏûëÌïòÍ∏∞');
    nextStep(); // step 1Î°ú Ïù¥Îèô
    setShowCurrentQuestion(true);
  };

  const currentQuestion = getCurrentQuestion();
  const showStartButton = currentStep === 0 && messages.length > 0;

  // ÎèôÏ†Å ÏòµÏÖòÏù¥ ÏûàÎäî Í≤ΩÏö∞ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ ÏòµÏÖò ÏÇ¨Ïö©
  const currentOptions = (() => {
    if (!currentQuestion) return [];

    const isChoiceOrMixed =
      currentQuestion.type === 'choice' || currentQuestion.type === 'mixed';

    if (isChoiceOrMixed) {
      // step 8Î∂ÄÌÑ∞Îäî Í∏∞Î≥∏ ÏòµÏÖò ÏÇ¨Ïö©
      if (currentQuestion.step >= 8) {
        return currentQuestion.options || [];
      }

      // step 7ÍπåÏßÄÎäî ÎèôÏ†Å ÏòµÏÖò ÏÇ¨Ïö©
      if (isLoadingOptions) {
        return currentQuestion.options || [];
      }
      if (dynamicOptions.length > 0) {
        return dynamicOptions;
      }
    }

    return currentQuestion.options || [];
  })();

  const showQuestionOptions =
    currentQuestion && currentOptions && currentOptions.length > 0;

  // Î°úÎî© ÏÉÅÌÉú Ï≤òÎ¶¨
  if (userLoading) {
    return (
      <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
        <div className="text-center">
          <p className="text-chat-message">ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</p>
        </div>
      </div>
    );
  }

  // Î°úÍ∑∏ÏïÑÏõÉ ÏÉÅÌÉú ÌôïÏù∏
  const isLoggedOut = !userData?.data;

  return (
    <>
      {/* Î°úÍ∑∏ÏïÑÏõÉ ÏÉÅÌÉúÏùº Îïå ÌëúÏãúÌï† ÏóêÎü¨ Ïª¥Ìè¨ÎÑåÌä∏ */}
      {isLoggedOut && (
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50">
          <div className="flex flex-col items-center gap-4">
            <Image
              src="/assets/logos/bad-gate-star.svg"
              alt="ÍøàÎ≥ÑÏù¥ errorÌéòÏù¥ÏßÄ Ïù¥ÎØ∏ÏßÄ"
              width={375}
              height={316}
              className="max-w-full h-auto"
            />
            <div className="text-center">
              <h1 className="text-lg lg:text-2xl font-bold text-gray-50 mb-2">
                Î°úÍ∑∏Ïù∏ ÌõÑ Ïù¥Ïö©Ìï¥Î≥¥ÏÑ∏Ïöî!
              </h1>
            </div>
          </div>
        </div>
      )}

      <div
        className={`absolute top-[10vh] xs:top-[10vh] md:top-[10vh] lg:top-[10vh] left-1/2 transform -translate-x-1/2 max-w-[95vw] xs:max-w-[90vw] md:max-w-[800px] lg:max-w-[1200px] w-full px-2 xs:px-4 md:px-6 lg:px-0 ${isLoggedOut ? 'blur-sm pointer-events-none' : ''}`}
      >
        <MessageSection
          messages={messages}
          showStartButton={showStartButton}
          showQuestionOptions={showQuestionOptions || false}
          currentQuestionOptions={currentOptions}
          selectedOptions={selectedOptions}
          canSkip={currentQuestion?.canSkip || false}
          onStartClick={handleStartClick}
          onOptionClick={handleOptionClick}
          onCompleteClick={handleCompleteClick}
          onSkipClick={handleSkipClick}
        />

        {/* ÏßÑÌñâÎ∞î Î∞è ÏûÖÎ†•Ï∞Ω Ïª®ÌÖåÏù¥ÎÑà
      <div className="w-full max-w-[400px] xs:max-w-[1000px] md:max-w-[1000px] lg:max-w-[1200px] flex justify-center"> */}
        {/* ÏßÑÌñâÎ∞î */}
        {currentStep > 0 && !isLoadingRecommendations && !isCompleted && (
          <div className="absolute bottom-[10vh] xs:bottom-[10vh] md:bottom-[13vh] lg:bottom-[14vh] left-1/2 transform -translate-x-1/2 w-full flex justify-center items-center animate-slide-up-fade">
            <ProgressBar
              currentStep={currentStep}
              totalSteps={aiChatFlow.questions.length}
            />
          </div>
        )}

        {/* ÏûÖÎ†•Ï∞Ω */}
        <div className="absolute bottom-[3vh] md:bottom-[2vh] lg:bottom-[2.8vh] left-1/2 transform -translate-x-1/2 w-full max-w-[400px] xs:max-w-[1000px] md:max-w-[1000px] lg:max-w-[1200px] max-h-[15.5vh] xs:max-h-[15.5vh] md:max-h-[15vh] lg:max-h-[15.96vh] flex justify-center animate-slide-up-bounce">
          <ChatInput
            value={textInput}
            onChange={setTextInput}
            onSend={handleCompleteClick}
          />
        </div>
      </div>
    </>
  );
}

export default function AIChatJob() {
  return (
    <ChatHistoryProvider>
      <AIChatJobContent />
    </ChatHistoryProvider>
  );
}
